\documentclass[handout]{beamer}
\usepackage{amsmath,amssymb,amsthm}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}

\title{Научно-исследовательская практика}
\subtitle{Домино}
\author{Кураленко Антон Сергеевич\\Микрюков Данила Александрович}
\institute{Институт физико-математических наук и информационных технологий БФУ им. И. Канта}
\date{1 июля 2022 года}

\newtheorem*{myproblem}{Домино}
\newtheorem*{rules}{Правила реализованной версии игры}
\newtheorem*{classes1}{Классы}
\newtheorem*{classes2}{Класс Domino}
\newtheorem*{classes3}{Класс Chain}
\newtheorem*{classes4}{Класс Scope}
\newtheorem*{classes5}{Класс Storage}
\newtheorem*{classes6}{Классы CmpPool и PLayerPool}
\newtheorem*{comp1}{Механика ходов компьютера (класс Ai)}
\newtheorem*{comp2}{Принцип работы AI}
\newtheorem*{modules}{Модули}

\begin{document}
	
	\section{Титульный лист}
	\begin{frame}
		\titlepage
	\end{frame}
	
	\section{Описание механики игры}
	\begin{frame}{Описание механики игры}
		\begin{myproblem}
		 настольная игра, в процессе которой выстраивается цепь костяшек, соприкасающихся половинками с одинаковым количеством точек, обозначающим число очков. Каждый символ из набора, как правило, имеет числовое значение. Сумма точек всех костей одного игрального набора домино равна 168.
		\end{myproblem}
	\end{frame}

	\begin{frame}{Описание механики игры}
	\begin{rules}
		На момент начала игры у каждого игрока 7 костяшек в руке, на поле находится 1 костяшка, всего в игре 28 костяшек. Игроки по очереди выставляют костяшки, стараясь избавиться от них, соблюдая при этом нужное количество точек и выстраивая горизонтальную цепочку. Если у игрока нет костяшки, которую он может выставить на поле, то он берет одну костяшку из хранилища и пропускает ход. Побеждает игрок, который раньше избавится от всех костяшек. Если у обоих игроков нет доступных ходов и в хранилище нет костяшек, то объявляется ничья. 
	\end{rules}
\end{frame}
	
	\section{Описание реализации}
	\begin{frame}{Описание реализации}
		\begin{classes1}
			\textbf{Domino:} Служит для представления и отображения отдельных домино;\\
			\textbf{Chain:} Служит для хранения и отображения цепочки домино;\\
			\textbf{Scope:} Служит для вывода на экран текущего видимого участка цепочки;\\
			\textbf{Storage:} Хранилище домино - база, из которой могут брать домино игрок и компьютер;\\
			\textbf{PLayerPool:} Домино игрока;\\
			\textbf{CmpPool:} Домино компьютера;\\
			\textbf{Ai:} Отвечает за выбор хода компьютера. 
		
		\end{classes1}
 	 \end{frame}
  
  	\section{Описание реализации}
  \begin{frame}{Описание реализации}	
  	\begin{classes2}
  	 \textbf{Свойства Domino:} Side1, Side2, CornerPoints, Surface, Rect, Orientation, IsDouble, IsRightOrientation, IsLeftOrientation, Width, Height, RIGHTORIENTATION, DOWNORIENTATION,  LEFTORIENTATION, UPORIENTATION, VERTICALORIENTATIONS, HORIZONTALORIENTATION;\\
  	  \textbf{Методы Domino:}\\
  	  1) \textbf{CreateCoords:} Формирует координаты угловых точек домино, координаты точек самих домино и координаты разделительной линии;\\
  	  2) \textbf{CreateSurface:} Формируется поверхность для отдельно взятого домино (рисует точки, разделительную линию, задает фон и тд);\\
  	  3) \textbf{CreateRect:} Возвращает прямоугольную область домино с его координатами и размером;\\
  	  4) \textbf{Rotate:} Переворачивает домино к заданной ориентации.\\
  		
  	\end{classes2}
  \end{frame}


	\section{Описание реализации}
\begin{frame}{Описание реализации}	
	\begin{classes3}
		\textbf{Свойства Chain:} ChainElements, LeftLine, RightLine, LeftSide, RightSide Surface, Width, CenterLine, LeftDomino, RightDomino, DominoList;\\
		\textbf{Методы Chain:} \\
		1) \textbf{AddFirstDomino:} Добавляет первое домино в список;\\
		2) \textbf{AddToRight:} Добавляет домино в список справа методом append;\\
		3) \textbf{AddToLeft:} Добавляет домино в начало списка (методом insert на нулевую позицию);\\
		4) \textbf{CreateSurface:} Возвращает поверхность для видимого участка цепочки.\\
		
	\end{classes3}
\end{frame}

	\section{Описание реализации}
\begin{frame}{Описание реализации}	
	\begin{classes4}
		\textbf{Свойства Scope:} SCROLLLIMIT, Chain, LeftLine, MoveToLine;\\
		\textbf{Методы Scope:} \\
		1) \textbf{MoveToLeft:} Метод для перехода в левую часть цепочки;\\
		2) \textbf{MoveToRight:}  Метод для перехода в правую часть цепочки;\\
		3) \textbf{MoveToLine:} Метод для перехода в центр цепочки;\\
	    4) \textbf{RectInScope:} Метод для проверки вхождения домино в видимую область.\\		
	\end{classes4}
\end{frame}

\section{Описание реализации}
\begin{frame}{Описание реализации}	
	\begin{classes5}
		\textbf{Свойства Storage:} BACKGROUNDCOLOR1, BACKGROUNDCOLOR2, CIRCLECOLOR, FONTCOLOR, DominoList, Surface, Font, LastChainLeft, StorageSize, IsEmpty;\\
		\textbf{Методы Storage:} \\
		1) \textbf{CreateSurface:} Создает поверхность для отображения хранилища и количество домино в хранилище ;\\
		2) \textbf{TakeDomino:} Метод, удаляющий домино из хранилища;\\
		3) \textbf{Click:} Метод, срабатывающий по клику игрока, который удаляет одно домино из списка хранилища, добавляет домино в пул игрока и присваивает значения крайних домино в цепочке двум переменным;\\
		4) \textbf{GetLastChainSides:} Метод возвращает значения, на концах цепочки во время последнего взятия игроком домино из хранилища.\\		
	\end{classes5}
\end{frame}



  	\begin{frame}{Описание реализации}
  	\begin{classes6}
В данных классах мы описываем костяшки на руках игрока и костяшки на руках компьютера, доступность ходов игрока и стрелки, позволяющие игроку ставить костяшки на левый или правый край цепочки.\\
    \textbf{Свойства CmpPool:} PoolSize, IsEmpty, DominoList, Pool, Chain, Surface, PANEWIDTH, PANEHEIGHT;\\
	\textbf{Методы CmpPool:}\\
	 1) \textbf{CreateSurface:} Отвечает за формирование поверхности, отображающей перевернутые домино у компьютера;\\
	 2) \textbf{AddDomino:} Добавляет домино в пул компьютера из хранилища;\\
	 3) \textbf{RemoveDomino:} Удаляет одно домино из пула компьютера.\\		
  	\end{classes6}
  \end{frame}

\begin{frame}{Описание реализации}
	\begin{classes6}
		 \textbf{Свойства PLayerPool:} PoolSize, IsEmpty, DominoList, Pool, Chain, Surface, PANEWIDTH, PANEHEIGHT, TOLEFTBUTTONCOORDS, TORIGHTBUTTONCOORDS, ARROWCOLOR;\\
		\textbf{Методы PLayerPool:}\\
		1) \textbf{CreateSurface:} Отвечает за формирование поверхности, отображающей домино у игрока, а также стрелок над доступными для хода домино;\\
		2) \textbf{AddDomino:} Добавляет домино в пул игрока из хранилища;\\
		3) \textbf{Click:} Добавление домино в левый или правый край цепочки (в зависимости от нажатой стрелки) и удаление соотвествующего домино из пула игрока.\\
		
	\end{classes6}
\end{frame}
  
  \section{Описание реализации}
 	\begin{frame}{Описание реализации}
 		\begin{comp1}
 			Для определения хода компьютера каждому ходу необходимо было ввести рейтинг, вычисляемый в соотвествии со следующими правилами:\\
 			1) Надо стремиться избавляться от дублей. Ход дублем тем ценнее, чем больше домино с его мастью уже вышло из игры.\\
 			2) Надо стремиться ставить в цепочку домино с такими мастями, чтобы вероятность их нахождения у игрока на руках была минимальной.\\
 			3) Нужно отслеживать состояние цепочки в тот момент, когда игрок берет домино из кучи. Те масти, которые находятся в этот момент на концах цепочки - отсутствуют у игрока. И нужно стремиться снова выставить их на концы цепочки, чтобы игрок пропускал ход или вновь добирал домино из кучи. 
 		\end{comp1}
 \end{frame}

  \section{Описание реализации}
\begin{frame}{Описание реализации}
	\begin{comp2}
	Первым делом, формируется список доступных ходов компьютера. Если доступных ходов нет, тогда берем одно домино из хранилища. Если после этого доступных ходов нет, компьютер пропускает ход. Если если в списке один доступный код, иначе высчитываем рейтинг следующим образом. Идем по списку доступных ходов с помощью цикла, если это ход дублем, тогда идем в цикл, перебирающий элементы цепочки и прибавляем рейтинг на единицу в случае, если значение домино уже есть в цепи. Далее мы запоминаем значения крайних элементов цепи, после применения хода. Дальше мы идем по списку состоящему из домино находящихся в цепи и домино находящихся в пуле у компьютера.
	\end{comp2}
\end{frame}


 \section{Описание реализации}
\begin{frame}{Описание реализации}
	\begin{comp2}
		  Если значение правой или левой стороны домино равняется крайнему левому значению цепи, тогда прибавляем рейтинг хода на единицу. Аналогично сравниваем все значения из списка с крайнем правым значением домино из цепи. Далее проверяем, совпадают ли полученные в результате применения тестируемого хода масти на концах цепочки с теми, которые были во время последнего обращения игрока к хранилищу. Если совпадают, тогда добавляем дополнительные очки к ходу. После вычисляем максимальный рейтинг из всех рейтингов ходов. После завершения цикла фильтруем список состоящий из ходов имеющий максимальный рейтинг, и выбираем случайным образом ход из данного списка.
		 После всего - применяем ход
	\end{comp2}
\end{frame}

  \begin{frame}{Описание реализации}
	
	\begin{modules}
    \textbf{Pygame:} набор модулей языка программирования Python, предназначенный для написания компьютерных игр и мультимедиа-приложений\\
     \textbf{Файлы игры:}\\
     \textbf{start:} С него начинается выполнение программы. Он содержит основной цикл pygame, а также код, создающий объекты всех основных классов. Функционирование программы построено на взаимодействии между объектами и изменении ими внутреннего состояния друг друга;\\
     \textbf{classes:} Файл со всеми классами игры;\\
     \textbf{utils:} Файл с общими разделяемыми функциями и функциями отрисовки слоёв;\\
     \textbf{settings:} Файл с настройками (настройки цветов, размеров и положений объектов т.п.).
	\end{modules}
\end{frame}

	
	\section{Демонстрация}
	\begin{frame}{Он-лайн демонстрация кода и его работы}
		Сейчас мы продемонстрируем нашу игру!\centering		
	\end{frame}
	
	
	\section{Заключение}
	\begin{frame}{Заключение}
		 В этой научно-исследовательской работе мы познакомились с функционалом pygame и научились создавать код для небольших игр.		
	\end{frame}
	
\end{document}